
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

struct LineChartSpecViewDataDataSetsValuesStruct {
  int x{0};
  int y{0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewDataDataSetsValuesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
}

static inline std::string toString(const LineChartSpecViewDataDataSetsValuesStruct &value) {
  return "[Object LineChartSpecViewDataDataSetsValuesStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<LineChartSpecViewDataDataSetsValuesStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    LineChartSpecViewDataDataSetsValuesStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct LineChartSpecViewDataDataSetsLimitLineEntityStruct {
  Float lineWidth{0.0};
  std::string lineColor{};
  std::vector<Float> lineDashLengths{};
  std::string labelPosition{};
  Float fontSize{0.0};
  Float limit{0.0};
  std::string label{};
  std::string labelValueColor{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewDataDataSetsLimitLineEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_lineWidth = map.find("lineWidth");
  if (tmp_lineWidth != map.end()) {
    fromRawValue(context, tmp_lineWidth->second, result.lineWidth);
  }
  auto tmp_lineColor = map.find("lineColor");
  if (tmp_lineColor != map.end()) {
    fromRawValue(context, tmp_lineColor->second, result.lineColor);
  }
  auto tmp_lineDashLengths = map.find("lineDashLengths");
  if (tmp_lineDashLengths != map.end()) {
    fromRawValue(context, tmp_lineDashLengths->second, result.lineDashLengths);
  }
  auto tmp_labelPosition = map.find("labelPosition");
  if (tmp_labelPosition != map.end()) {
    fromRawValue(context, tmp_labelPosition->second, result.labelPosition);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue(context, tmp_fontSize->second, result.fontSize);
  }
  auto tmp_limit = map.find("limit");
  if (tmp_limit != map.end()) {
    fromRawValue(context, tmp_limit->second, result.limit);
  }
  auto tmp_label = map.find("label");
  if (tmp_label != map.end()) {
    fromRawValue(context, tmp_label->second, result.label);
  }
  auto tmp_labelValueColor = map.find("labelValueColor");
  if (tmp_labelValueColor != map.end()) {
    fromRawValue(context, tmp_labelValueColor->second, result.labelValueColor);
  }
}

static inline std::string toString(const LineChartSpecViewDataDataSetsLimitLineEntityStruct &value) {
  return "[Object LineChartSpecViewDataDataSetsLimitLineEntityStruct]";
}

struct LineChartSpecViewDataDataSetsGradientColorsDataStruct {
  std::string from{};
  std::string to{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewDataDataSetsGradientColorsDataStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_from = map.find("from");
  if (tmp_from != map.end()) {
    fromRawValue(context, tmp_from->second, result.from);
  }
  auto tmp_to = map.find("to");
  if (tmp_to != map.end()) {
    fromRawValue(context, tmp_to->second, result.to);
  }
}

static inline std::string toString(const LineChartSpecViewDataDataSetsGradientColorsDataStruct &value) {
  return "[Object LineChartSpecViewDataDataSetsGradientColorsDataStruct]";
}

struct LineChartSpecViewDataDataSetsStruct {
  std::vector<LineChartSpecViewDataDataSetsValuesStruct> values{};
  LineChartSpecViewDataDataSetsLimitLineEntityStruct limitLineEntity{};
  std::string label{};
  LineChartSpecViewDataDataSetsGradientColorsDataStruct gradientColorsData{};
  bool drawVerticalHighlightIndicatorEnabled{false};
  bool drawHorizontalHighlightIndicatorEnabled{false};
  bool drawValuesEnabled{false};
  std::string mode{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewDataDataSetsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_values = map.find("values");
  if (tmp_values != map.end()) {
    fromRawValue(context, tmp_values->second, result.values);
  }
  auto tmp_limitLineEntity = map.find("limitLineEntity");
  if (tmp_limitLineEntity != map.end()) {
    fromRawValue(context, tmp_limitLineEntity->second, result.limitLineEntity);
  }
  auto tmp_label = map.find("label");
  if (tmp_label != map.end()) {
    fromRawValue(context, tmp_label->second, result.label);
  }
  auto tmp_gradientColorsData = map.find("gradientColorsData");
  if (tmp_gradientColorsData != map.end()) {
    fromRawValue(context, tmp_gradientColorsData->second, result.gradientColorsData);
  }
  auto tmp_drawVerticalHighlightIndicatorEnabled = map.find("drawVerticalHighlightIndicatorEnabled");
  if (tmp_drawVerticalHighlightIndicatorEnabled != map.end()) {
    fromRawValue(context, tmp_drawVerticalHighlightIndicatorEnabled->second, result.drawVerticalHighlightIndicatorEnabled);
  }
  auto tmp_drawHorizontalHighlightIndicatorEnabled = map.find("drawHorizontalHighlightIndicatorEnabled");
  if (tmp_drawHorizontalHighlightIndicatorEnabled != map.end()) {
    fromRawValue(context, tmp_drawHorizontalHighlightIndicatorEnabled->second, result.drawHorizontalHighlightIndicatorEnabled);
  }
  auto tmp_drawValuesEnabled = map.find("drawValuesEnabled");
  if (tmp_drawValuesEnabled != map.end()) {
    fromRawValue(context, tmp_drawValuesEnabled->second, result.drawValuesEnabled);
  }
  auto tmp_mode = map.find("mode");
  if (tmp_mode != map.end()) {
    fromRawValue(context, tmp_mode->second, result.mode);
  }
}

static inline std::string toString(const LineChartSpecViewDataDataSetsStruct &value) {
  return "[Object LineChartSpecViewDataDataSetsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<LineChartSpecViewDataDataSetsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    LineChartSpecViewDataDataSetsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct LineChartSpecViewDataStruct {
  std::vector<LineChartSpecViewDataDataSetsStruct> dataSets{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewDataStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_dataSets = map.find("dataSets");
  if (tmp_dataSets != map.end()) {
    fromRawValue(context, tmp_dataSets->second, result.dataSets);
  }
}

static inline std::string toString(const LineChartSpecViewDataStruct &value) {
  return "[Object LineChartSpecViewDataStruct]";
}

struct LineChartSpecViewAnimationEntityStruct {
  Float xAxisDuration{0.0};
  Float yAxisDuration{0.0};
  std::string xAxisEasing{};
  std::string yAxisEasing{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewAnimationEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_xAxisDuration = map.find("xAxisDuration");
  if (tmp_xAxisDuration != map.end()) {
    fromRawValue(context, tmp_xAxisDuration->second, result.xAxisDuration);
  }
  auto tmp_yAxisDuration = map.find("yAxisDuration");
  if (tmp_yAxisDuration != map.end()) {
    fromRawValue(context, tmp_yAxisDuration->second, result.yAxisDuration);
  }
  auto tmp_xAxisEasing = map.find("xAxisEasing");
  if (tmp_xAxisEasing != map.end()) {
    fromRawValue(context, tmp_xAxisEasing->second, result.xAxisEasing);
  }
  auto tmp_yAxisEasing = map.find("yAxisEasing");
  if (tmp_yAxisEasing != map.end()) {
    fromRawValue(context, tmp_yAxisEasing->second, result.yAxisEasing);
  }
}

static inline std::string toString(const LineChartSpecViewAnimationEntityStruct &value) {
  return "[Object LineChartSpecViewAnimationEntityStruct]";
}

struct LineChartSpecViewMarkerEntityPositionStruct {
  Float left{0.0};
  Float top{0.0};
  Float bottom{0.0};
  Float right{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewMarkerEntityPositionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
}

static inline std::string toString(const LineChartSpecViewMarkerEntityPositionStruct &value) {
  return "[Object LineChartSpecViewMarkerEntityPositionStruct]";
}

struct LineChartSpecViewMarkerEntityCircleEntityStruct {
  Float size{0.0};
  std::string color{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewMarkerEntityCircleEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
}

static inline std::string toString(const LineChartSpecViewMarkerEntityCircleEntityStruct &value) {
  return "[Object LineChartSpecViewMarkerEntityCircleEntityStruct]";
}

struct LineChartSpecViewMarkerEntityStruct {
  std::string bgColor{};
  std::string color{};
  Float fontSize{0.0};
  LineChartSpecViewMarkerEntityPositionStruct position{};
  LineChartSpecViewMarkerEntityCircleEntityStruct circleEntity{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewMarkerEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_bgColor = map.find("bgColor");
  if (tmp_bgColor != map.end()) {
    fromRawValue(context, tmp_bgColor->second, result.bgColor);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue(context, tmp_fontSize->second, result.fontSize);
  }
  auto tmp_position = map.find("position");
  if (tmp_position != map.end()) {
    fromRawValue(context, tmp_position->second, result.position);
  }
  auto tmp_circleEntity = map.find("circleEntity");
  if (tmp_circleEntity != map.end()) {
    fromRawValue(context, tmp_circleEntity->second, result.circleEntity);
  }
}

static inline std::string toString(const LineChartSpecViewMarkerEntityStruct &value) {
  return "[Object LineChartSpecViewMarkerEntityStruct]";
}

struct LineChartSpecViewXAxisEntityLabelFontStruct {
  Float size{0.0};
  std::string weight{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewXAxisEntityLabelFontStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
  auto tmp_weight = map.find("weight");
  if (tmp_weight != map.end()) {
    fromRawValue(context, tmp_weight->second, result.weight);
  }
}

static inline std::string toString(const LineChartSpecViewXAxisEntityLabelFontStruct &value) {
  return "[Object LineChartSpecViewXAxisEntityLabelFontStruct]";
}

struct LineChartSpecViewXAxisEntityStruct {
  bool drawLabelsEnabled{false};
  std::string labelPosition{};
  LineChartSpecViewXAxisEntityLabelFontStruct labelFont{};
  std::string labelTextColor{};
  Float yOffset{0.0};
  Float xOffset{0.0};
  Float axisMin{0.0};
  Float axisMax{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewXAxisEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_drawLabelsEnabled = map.find("drawLabelsEnabled");
  if (tmp_drawLabelsEnabled != map.end()) {
    fromRawValue(context, tmp_drawLabelsEnabled->second, result.drawLabelsEnabled);
  }
  auto tmp_labelPosition = map.find("labelPosition");
  if (tmp_labelPosition != map.end()) {
    fromRawValue(context, tmp_labelPosition->second, result.labelPosition);
  }
  auto tmp_labelFont = map.find("labelFont");
  if (tmp_labelFont != map.end()) {
    fromRawValue(context, tmp_labelFont->second, result.labelFont);
  }
  auto tmp_labelTextColor = map.find("labelTextColor");
  if (tmp_labelTextColor != map.end()) {
    fromRawValue(context, tmp_labelTextColor->second, result.labelTextColor);
  }
  auto tmp_yOffset = map.find("yOffset");
  if (tmp_yOffset != map.end()) {
    fromRawValue(context, tmp_yOffset->second, result.yOffset);
  }
  auto tmp_xOffset = map.find("xOffset");
  if (tmp_xOffset != map.end()) {
    fromRawValue(context, tmp_xOffset->second, result.xOffset);
  }
  auto tmp_axisMin = map.find("axisMin");
  if (tmp_axisMin != map.end()) {
    fromRawValue(context, tmp_axisMin->second, result.axisMin);
  }
  auto tmp_axisMax = map.find("axisMax");
  if (tmp_axisMax != map.end()) {
    fromRawValue(context, tmp_axisMax->second, result.axisMax);
  }
}

static inline std::string toString(const LineChartSpecViewXAxisEntityStruct &value) {
  return "[Object LineChartSpecViewXAxisEntityStruct]";
}

struct LineChartSpecViewYAxisEntityLabelFontStruct {
  Float size{0.0};
  std::string weight{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewYAxisEntityLabelFontStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
  auto tmp_weight = map.find("weight");
  if (tmp_weight != map.end()) {
    fromRawValue(context, tmp_weight->second, result.weight);
  }
}

static inline std::string toString(const LineChartSpecViewYAxisEntityLabelFontStruct &value) {
  return "[Object LineChartSpecViewYAxisEntityLabelFontStruct]";
}

struct LineChartSpecViewYAxisEntityStruct {
  bool drawLabelsEnabled{false};
  std::string labelPosition{};
  LineChartSpecViewYAxisEntityLabelFontStruct labelFont{};
  std::string labelTextColor{};
  Float xOffset{0.0};
  Float yOffset{0.0};
  Float axisMin{0.0};
  Float axisMax{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, LineChartSpecViewYAxisEntityStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_drawLabelsEnabled = map.find("drawLabelsEnabled");
  if (tmp_drawLabelsEnabled != map.end()) {
    fromRawValue(context, tmp_drawLabelsEnabled->second, result.drawLabelsEnabled);
  }
  auto tmp_labelPosition = map.find("labelPosition");
  if (tmp_labelPosition != map.end()) {
    fromRawValue(context, tmp_labelPosition->second, result.labelPosition);
  }
  auto tmp_labelFont = map.find("labelFont");
  if (tmp_labelFont != map.end()) {
    fromRawValue(context, tmp_labelFont->second, result.labelFont);
  }
  auto tmp_labelTextColor = map.find("labelTextColor");
  if (tmp_labelTextColor != map.end()) {
    fromRawValue(context, tmp_labelTextColor->second, result.labelTextColor);
  }
  auto tmp_xOffset = map.find("xOffset");
  if (tmp_xOffset != map.end()) {
    fromRawValue(context, tmp_xOffset->second, result.xOffset);
  }
  auto tmp_yOffset = map.find("yOffset");
  if (tmp_yOffset != map.end()) {
    fromRawValue(context, tmp_yOffset->second, result.yOffset);
  }
  auto tmp_axisMin = map.find("axisMin");
  if (tmp_axisMin != map.end()) {
    fromRawValue(context, tmp_axisMin->second, result.axisMin);
  }
  auto tmp_axisMax = map.find("axisMax");
  if (tmp_axisMax != map.end()) {
    fromRawValue(context, tmp_axisMax->second, result.axisMax);
  }
}

static inline std::string toString(const LineChartSpecViewYAxisEntityStruct &value) {
  return "[Object LineChartSpecViewYAxisEntityStruct]";
}
class LineChartSpecViewProps final : public ViewProps {
 public:
  LineChartSpecViewProps() = default;
  LineChartSpecViewProps(const PropsParserContext& context, const LineChartSpecViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  LineChartSpecViewDataStruct data{};
  bool dragEnabled{false};
  std::string bgColor{};
  LineChartSpecViewAnimationEntityStruct animationEntity{};
  bool drawGridLinesEnabled{false};
  LineChartSpecViewMarkerEntityStruct markerEntity{};
  LineChartSpecViewXAxisEntityStruct xAxisEntity{};
  LineChartSpecViewYAxisEntityStruct yAxisEntity{};
  bool highlightPerTapEnabled{false};
  bool highlightPerDragEnabled{false};
};

} // namespace facebook::react
